<?xml version="1.0" encoding="UTF-8" ?>

<section xmlns:xi="http://www.w3.org/2001/XInclude" xml:id="sec_cylindrical_spherical">
  <title>Triple Integration with Cylindrical and Spherical Coordinates</title>
  <introduction>
    <p>
      Just as polar coordinates gave us a new way of describing curves in the plane,
      in this section we will see how
      <em>cylindrical</em> and <em>spherical</em>
      coordinates give us new ways of desribing surfaces and regions in space.
    </p>

    <figure xml:id="vid-multint-cylindrical-intro" component="video">
      <caption>A triple integral that isn't easily performed in rectancular coordinates</caption>
      <video youtube="Ajd8uy3U4lA"/>
    </figure>
  </introduction>

  <subsection>
    <title>Cylindrical Coordinates</title>
    <p>
      In short, cylindrical coordinates can be thought of as a combination of the polar and rectangular coordinate systems.
      One can identify a point <m>(x_0,y_0,z_0)</m>,
      given in rectangular coordinates,
      with the point <m>(r_0,\theta_0,z_0)</m>,
      given in cylindrical coordinates,
      where the <m>z</m>-value in both systems is the same,
      and the point <m>(x_0,y_0)</m> in the <m>xy</m>-plane is identified with the polar point <m>P(r_0,\theta_0)</m>;
      see <xref ref="fig_cylindricalintro">Figure</xref>.
      So that each point in space that does not lie on the <m>z</m>-axis is defined uniquely,
      we will restrict <m>r\geq 0</m> and <m>0\leq \theta\leq 2\pi</m>.
          <idx><h>cylindrical coordinates</h></idx>
          <idx><h>coordinates</h><h>cylindrical</h></idx>
    </p>

    <figure xml:id="fig_cylindricalintro">
      <caption>Illustrating the principles behind cylindrical coordinates</caption>
      <image xml:id="img_cylindricalintro_3D" width="47%">
        <description></description>
        <asymptote>

          //import apexstyle;


          //ASY file for figstokes2_3D.asy in Chapter 13


          size(282,282,IgnoreAspect);
          //currentprojection=perspective(7,2,1);
          currentprojection=orthographic(24,17,11.6);
          defaultrender.merge=true;

          // setup and draw the axes
          real[] myxchoice={};
          real[] myychoice={};
          real[] myzchoice={};
          defaultpen(0.5mm);

          pair xbounds=(-.1,1.1);
          pair ybounds=(-.1,1.1);
          pair zbounds=(-.1,1.1);

          xaxis3("",xbounds.x,xbounds.y,black,OutTicks(myxchoice),Arrow3(size=3mm));
          yaxis3("",ybounds.x,ybounds.y,black,OutTicks(myychoice),Arrow3(size=3mm));
          zaxis3("",zbounds.x,zbounds.y,black,OutTicks(myzchoice),Arrow3(size=3mm));

          label("$x$",(xbounds.y+0.05*(xbounds.y-xbounds.x),0,0));
          label("$y$",(0,ybounds.y+0.05*(ybounds.y-ybounds.x),0));
          label("$z$",(0,0,zbounds.y+0.05*(zbounds.y-zbounds.x)));

          draw((.5,sqrt(3)/2,1)--(.5,sqrt(3)/2,0)--(0,0,0),dashed);

          draw(arc((0,0,0),(.5,0,0),(.25,sqrt(3)/4,0)),Arrow3(size=2mm));

          dot((.5,sqrt(3)/2,1),dotblue);

          label("$\theta$",(.55*cos(pi/6),.55*sin(pi/6),.1));

          label("$(r,\theta,z)$",(.5,sqrt(3)/2,1.1));

          label("$z$",(.5,sqrt(3)/2+.1,.5));

          label("$r$",(.20,sqrt(3)/4,0.05));

          //draw(s,emissive(gray+opacity(.3)),meshpen=invisible);


          //draw(s,simplesurfacepen,meshpen=apexmeshpen);



          //label("$\mathcal{S}$",(1,1,5));
          //draw((0,1,0)--(0,3,0)--(3,1,0)--cycle,curvepen);

        </asymptote>
      </image>
    </figure>

    <p>
      We use the identity <m>z=z</m> along with the identities found in <xref ref="idea_polarconvert">Key Idea</xref>
      to convert between the rectangular coordinate <m>(x,y,z)</m> and the cylindrical coordinate <m>(r,\theta,z)</m>, namely:
      <me>
        \begin{array}{l} \text{ From rectangular to cylindrical: }  r=\sqrt{x^2+y^2}, \tan(\theta) = y/x \text{ and }  z=z;\\
         \text{ From cylindrical to rectangular: }   x=r\cos(\theta),  y=r\sin(\theta) \text{ and }  z=z. \end{array}
      </me>
    </p>

    <aside>
      <p>
        Our rectangular to polar conversion formulas used <m>r^2=x^2+y^2</m>,
        allowing for negative <m>r</m> values.
        Since we now restrict <m>r\geq 0</m>,
        we can use <m>r=\sqrt{x^2+y^2}</m>.
      </p>
    </aside>

    <p>
      These identities,
      along with conversions related to spherical coordinates,
      are given later in <xref ref="idea_convert_coords">Key Idea</xref>.
    </p>

    <figure xml:id="vid-trigint-cylindrical-definition" component="video">
      <caption>Explaining the cylindrical coordinate system</caption>
      <video youtube="DOFhlADkGko"/>
    </figure>

    <example xml:id="ex_cylindrical4">
      <title>Converting between rectangular and cylindrical coordinates</title>
      <statement>
        <p>
          Convert the rectangular point
          <m>(2,-2,1)</m> to cylindrical coordinates,
          and convert the cylindrical point <m>(4,3\pi/4,5)</m> to rectangular.
        </p>
      </statement>
      <solution>
        <p>
          Following the identities given above (and,
          later in <xref ref="idea_convert_coords">Key Idea</xref>),
          we have <m>r = \sqrt{2^2+(-2)^2} = 2\sqrt{2}</m>.
          Using <m>\tan(\theta) = y/x</m>,
          we find <m>\theta = \tan^{-1}(-2/2) =-\pi/4</m>.
          As we restrict <m>\theta</m> to being between <m>0</m> and <m>2\pi</m>,
          we set <m>\theta = 7\pi/4</m>.
          Finally, <m>z = 1</m>,
          giving the cylindrical point <m>(2\sqrt2,7\pi/4,1)</m>.
        </p>

        <p>
          In converting the cylindrical point <m>(4,3\pi/4,5)</m> to rectangular,
          we have <m>x = 4\cos\big(3\pi/4\big) = -2\sqrt{2}</m>,
          <m>y = 4\sin\big(3\pi/4\big) = 2\sqrt{2}</m> and <m>z=5</m>,
          giving the rectangular point <m>(-2\sqrt{2},2\sqrt{2},5)</m>.
        </p>
      </solution>
    </example>

    <p>
      Setting each of <m>r</m>,
      <m>\theta</m> and <m>z</m> equal to a constant defines a surface in space,
      as illustrated in the following example.
    </p>

    <example xml:id="ex_cylindrical1">
      <title>Canonical surfaces in cylindrical coordinates</title>
      <statement>
        <p>
          Describe the surfaces <m>r=1</m>,
          <m>\theta = \pi/3</m> and <m>z=2</m>,
          given in cylindrical coordinates.
        </p>
      </statement>
      <solution>
        <p>
          The equation <m>r=1</m> describes all points in space that are 1 unit away from the <m>z</m>-axis.
          This surface is a <q>tube</q> or <q>cylinder</q>
          of radius 1, centered on the <m>z</m>-axis,
          as graphed in <xref ref="fig_spacecylinder1">Figure</xref>
          (which describes the cylinder <m>x^2+y^2=1</m> in space).
        </p>

        <p>
          The equation <m>\theta=\pi/3</m> describes the plane formed by extending the line <m>\theta=\pi/3</m>,
          as given by polar coordinates in the <m>xy</m>-plane,
          parallel to the <m>z</m>-axis.
        </p>

        <p>
          The equation <m>z=2</m> describes the plane of all points in space that are 2 units above the <m>xy</m>-plane.
          This plane is the same as the plane described by <m>z=2</m> in rectangular coordinates.
        </p>

        <figure xml:id="fig_cylindrical1">
          <caption>Graphing the canonical surfaces in cylindrical coordinates from <xref ref="ex_cylindrical1">Example</xref></caption>
          <image xml:id="img_cylindrical1_3D" width="47%">
            <description></description>
            <asymptote>

              //import apexstyle;


              //ASY file for figcylindrical1_3D.asy in Chapter 13


              size(282,282,IgnoreAspect);
              //currentprojection=perspective(7,2,1);
              currentprojection=orthographic(27,12,10);
              defaultrender.merge=true;

              // setup and draw the axes
              real[] myxchoice={1};
              real[] myychoice={1};
              real[] myzchoice={1,2};
              defaultpen(0.5mm);

              pair xbounds=(-2,2);
              pair ybounds=(-2,2);
              pair zbounds=(-.5,2.75);

              xaxis3("",xbounds.x,xbounds.y,black,OutTicks(myxchoice),Arrow3(size=3mm));
              yaxis3("",ybounds.x,ybounds.y,black,OutTicks(myychoice),Arrow3(size=3mm));
              zaxis3("",zbounds.x,zbounds.y,black,OutTicks(myzchoice),Arrow3(size=3mm));

              label("$x$",(xbounds.y+0.05*(xbounds.y-xbounds.x),0,0));
              label("$y$",(0,ybounds.y+0.05*(ybounds.y-ybounds.x),0));
              label("$z$",(0,0,zbounds.y+0.05*(zbounds.y-zbounds.x)));


              //Draw the plane  z=7-2x-2y
              triple f(pair t) {
              	return (t.x,t.y,2);//
              }
              surface s=surface(f,(-1.5,-1.5),(1.5,1.5),8,8,usplinetype=new splinetype[] {notaknot,notaknot,monotonic},vsplinetype=new splinetype[] {notaknot,notaknot,monotonic});
              pen p=bluemeshpen+.1mm;
              draw(s,simplesurfacepen,meshpen=p);

              draw((-1.5,-1.5,2) -- (-1.5,1.5,2) -- (1.5,1.5,2) -- (1.5,-1.5,2) -- (-1.5,-1.5,2),apexmeshpen+.25mm);


              //Draw the plane  z=7-2x-2y
              triple f(pair t) {
              	return (t.x,t.x*sqrt(3),t.y);//
              }
              surface s=surface(f,(0,-.5),(1.25,2.25),8,8,usplinetype=new splinetype[] {notaknot,notaknot,monotonic},vsplinetype=new splinetype[] {notaknot,notaknot,monotonic});
              pen q=redmeshpen2+.1mm;
              draw(s,simplesurfacepen2,meshpen=q);

              draw((0,0,-.5) -- (1.25,1.25*sqrt(3),-.5) -- (1.25,1.25*sqrt(3),2.25) -- (0,0,2.25) -- (0,0,-.5),redcurvepen+.25mm);


              //Draw the plane  z=7-2x-2y
              triple f(pair t) {
              	return (cos(t.x),sin(t.x),t.y);//
              }
              surface s=surface(f,(0,-.5),(2*pi,2.25),16,8,usplinetype=new splinetype[] {notaknot,notaknot,monotonic},vsplinetype=new splinetype[] {notaknot,notaknot,monotonic});
              pen q=greenmeshpen+.1mm;

              draw(s,simplesurfacepen3,meshpen=q);

              //dot((.5,sqrt(3)*.5,2),rgb(.1,.1,.1));

              draw((.5,sqrt(3)*.5,-.5)--(.5,sqrt(3)*.5,2.25));

              triple g(real t) {return (cos(t),sin(t),2);}
              path3 mypath=graph(g,0,2*pi,operator ..);
              draw(mypath,blackmeshpen);

              triple g(real t) {return (cos(t),sin(t),2.25);}
              path3 mypath=graph(g,0,2*pi,operator ..);
              draw(mypath,greencurvepen+.25mm);

              triple g(real t) {return (cos(t),sin(t),-.5);}
              path3 mypath=graph(g,0,2*pi,operator ..);
              draw(mypath,greencurvepen+.25mm);

              triple g(real t) {return (t,sqrt(3)*t,2);}
              path3 mypath=graph(g,0,.866,operator ..);

              draw(mypath,blackmeshpen);

              //draw(s,emissive(gray+opacity(.3)),meshpen=invisible);


              //draw(s,simplesurfacepen,meshpen=apexmeshpen);



              label("$z=2$",(-1.25,1.25,2.3));
              label("$r=1$",(1.1*cos(pi/6),1.1*sin(pi/6),-.75));

              label("$\theta=\frac{\pi}{3}$",(1.25,1.25*sqrt(3),1));

              //draw((0,1,0)--(0,3,0)--(3,1,0)--cycle,curvepen);
            </asymptote>
          </image>
        </figure>

        <p>
          All three surfaces are graphed in <xref ref="fig_cylindrical1">Figure</xref>.
          Note how their intersection uniquely defines the point <m>P=(1,\pi/3,2)</m>.
        </p>
      </solution>
    </example>

    <p>
      Cylindrical coordinates are useful when describing certain domains in space,
      allowing us to evaluate triple integrals over these domains more easily than if we used rectangular coordinates.
    </p>

    <p>
      <xref ref="thm_triple_integration2">Theorem</xref>
      shows how to evaluate <m>\iiint_Dh(x,y,z)\, dV</m> using rectangular coordinates.
      In that evaluation, we use <m>dV = dz\,dy\,dx</m>
      (or one of the other five orders of integration).
      Recall how, in this order of integration,
      the bounds on <m>y</m> are <q>curve to curve</q>
      and the bounds on <m>x</m> are <q>point to point</q>:
      these bounds describe a region <m>R</m> in the <m>xy</m>-plane.
      We could describe <m>R</m> using polar coordinates as done in <xref ref="sec_double_int_polar">Section</xref>.
      In that section, we saw how we used
      <m>dA = r\,dr\,d\theta</m> instead of <m>dA = dy\,dx</m>.
    </p>

    <p>
      Considering the above thoughts,
      we have <m>dV = dz\big(r\,dr\,d\theta\big) = r\,dz\,dr\,d\theta</m>.
      We set bounds on <m>z</m> as <q>surface to surface</q>
      as done in the previous section,
      and then use <q>curve to curve</q>
      and <q>point to point</q>
      bounds on <m>r</m> and <m>\theta</m>, respectively.
      Finally, using the identities given above,
      we change the integrand <m>h(x,y,z)</m> to <m>h(r,\theta,z)</m>.
    </p>

    <p>
      This process should sound plausible;
      the following theorem states it is truly a way of evaluating a triple integral.
    </p>

    <theorem xml:id="thm_triple_int_cylindrical">
      <title>Triple Integration in Cylindrical Coordinates</title>
      <statement>
        <p>
          Let <m>w=h(r,\theta,z)</m> be a continuous function on a closed,
          bounded region <m>D</m> in space,
          bounded in cylindrical coordinates by <m>\alpha \leq \theta \leq \beta</m>,
          <m>g_1(\theta)\leq r \leq g_2(\theta)</m> and <m>f_1(r,\theta) \leq z \leq f_2(r,\theta)</m>.
          Then <idx><h>integration</h><h>with cylindrical coordinates</h></idx>
          <me>
            \iiint_D h(r,\theta,z)\, dV = \int_\alpha^\beta\int_{g_1(\theta)}^{g_2(\theta)}\int_{f_1(r,\theta)}^{f_2(r,\theta)}h(r,\theta,z) r\,dz\,dr\,d\theta
          </me>.
        </p>
      </statement>
    </theorem>

    <figure xml:id="vid-multint-cylindrical-cone" component="video">
      <caption>Using cylindrical coordinates to find the volume of a cone</caption>
      <video youtube="u0FYs9MaI5k"/>
    </figure>

    <example xml:id="ex_cylindrical2">
      <title>Evaluating a triple integral with cylindrical coordinates</title>
      <statement>
        <p>
          Find the mass of the solid represented by the region in space bounded by <m>z=0</m>,
          <m>z=\sqrt{4-x^2-y^2}+3</m> and the cylinder <m>x^2+y^2=4</m>
          (as shown in <xref ref="fig_cylindrical2">Figure</xref>),
          with density function <m>\delta(x,y,z) = x^2+y^2+z+1</m>,
          using a triple integral in cylindrical coordinates.
          Distances are measured in centimeters and density is measured in grams per cubic centimeter.
        </p>
        <figure xml:id="fig_cylindrical2">
          <caption>Visualizing the solid used in <xref ref="ex_cylindrical2">Example</xref></caption>
          <image xml:id="img_cylindrical2_3D" width="47%">
            <description></description>
            <asymptote>

              //import apexstyle;


              //ASY file for figcylindrical2_3D.asy in Chapter 13


              size(282,282,IgnoreAspect);
              //currentprojection=perspective(7,2,1);
              currentprojection=orthographic(22,22,11);
              defaultrender.merge=true;

              // setup and draw the axes
              real[] myxchoice={2};
              real[] myychoice={2};
              real[] myzchoice={1,3,5};
              defaultpen(0.5mm);

              pair xbounds=(-2.5,2.5);
              pair ybounds=(-2.5,2.5);
              pair zbounds=(-.5,6);

              xaxis3("",xbounds.x,xbounds.y,black,OutTicks(myxchoice),Arrow3(size=3mm));
              yaxis3("",ybounds.x,ybounds.y,black,OutTicks(myychoice),Arrow3(size=3mm));
              zaxis3("",zbounds.x,zbounds.y,black,OutTicks(myzchoice),Arrow3(size=3mm));

              label("$x$",(xbounds.y+0.05*(xbounds.y-xbounds.x),0,0));
              label("$y$",(0,ybounds.y+0.05*(ybounds.y-ybounds.x),0));
              label("$z$",(0,0,zbounds.y+0.05*(zbounds.y-zbounds.x)));


              //Draw the plane  z=7-2x-2y
              triple f(pair t) {
              	return (2*t.y*cos(t.x),2*t.y*sin(t.x),sqrt(4-4*t.y^2)+3);//
              }
              surface s=surface(f,(0,0),(2pi,1),16,16,Spline);
              pen p=bluemeshpen+.1mm;
              draw(s,simplesurfacepen,meshpen=p);

              //draw((-1.5,-1.5,2) -- (-1.5,1.5,2) -- (1.5,1.5,2) -- (1.5,-1.5,2) -- (-1.5,-1.5,2),apexmeshpen+.25mm);


              //Draw the plane  z=7-2x-2y
              triple f(pair t) {
              	return (2*cos(t.x),2*sin(t.x),t.y);//
              }
              surface s=surface(f,(0,0),(2*pi,3),16,8,usplinetype=new splinetype[] {notaknot,notaknot,monotonic},vsplinetype=new splinetype[] {notaknot,notaknot,monotonic});
              pen p=bluemeshpen+.1mm;
              draw(s,simplesurfacepen,meshpen=p);



              //draw(s,emissive(gray+opacity(.3)),meshpen=invisible);


              //draw(s,simplesurfacepen,meshpen=apexmeshpen);




              //draw((0,1,0)--(0,3,0)--(3,1,0)--cycle,curvepen);
            </asymptote>
          </image>
        </figure>
      </statement>
      <solution>
        <p>
          We begin by describing this region of space with cylindrical coordinates.
          The plane <m>z=0</m> is left unchanged;
          with the identity <m>r=\sqrt{x^2+y^2}</m>,
          we convert the hemisphere of radius 2 to the equation <m>z=\sqrt{4-r^2}</m>;
          the cylinder <m>x^2+y^2=4</m> is converted to <m>r^2=4</m>,
          or, more simply, <m>r=2</m>.
          We also convert the density function:
          <m>\delta(r,\theta,z) = r^2+z+1</m>.
        </p>

        <p>
          To describe this solid with the bounds of a triple integral,
          we bound <m>z</m> with <m>0\leq z\leq \sqrt{4-r^2}+3</m>;
          we bound <m>r</m> with <m>0 \leq r \leq 2</m>;
          we bound <m>\theta</m> with <m>0 \leq \theta \leq 2\pi</m>.
        </p>

        <p>
          Using <xref ref="def_mass_3d">Definition</xref>
          and <xref ref="thm_triple_int_cylindrical">Theorem</xref>,
          we have the mass of the solid is
          <md>
            <mrow>M=\iiint_D\delta(x,y,z)\, dV \amp = \int_0^{2\pi}\int_0^2\int_0^{\sqrt{4-r^2}+3}\big(r^2+z+1\big)r\,dz\,dr\,d\theta</mrow>
            <mrow>\amp = \int_0^{2\pi}\int_0^2\big((r^3+4r)\sqrt{4-r^2}+\frac52r^3+\frac{19}2r\big)\,dr\,d\theta</mrow>
            <mrow>\amp = \frac{1318\pi}{15} \approx 276.04\,\text{g} </mrow>
          </md>,
          where we leave the details of the remaining double integral to the reader.
        </p>
      </solution>
    </example>

    <example xml:id="ex_cylindrical3">
      <title>Finding the center of mass using cylindrical coordinates</title>
      <statement>
        <p>
          Find the center of mass of the solid with constant density whose base can be described by the polar curve
          <m>r=\cos(3\theta)</m> and whose top is defined by the plane <m>z=1-x+0.1y</m>,
          where distances are measured in feet,
          as seen in <xref ref="fig_cylindrical3">Figure</xref>.
          (The volume of this solid was found in <xref ref="ex_doublepol4">Example</xref>.)
        </p>
        <figure xml:id="fig_cylindrical3">
          <caption>Visualizing the solid used in <xref ref="ex_cylindrical3">Example</xref></caption>
          <image xml:id="img_doublepol4_3D" width="47%">
            <description></description>
            <asymptote>


              //ASY file for figdoublepol43D.asy in Chapter 13


              size(282,282,IgnoreAspect);
              //currentprojection=perspective(7,2,1);
              currentprojection=orthographic(4,4,2);
              defaultrender.merge=true;

              // setup and draw the axes
              real[] myxchoice={};
              real[] myychoice={};
              real[] myzchoice={};
              defaultpen(0.5mm);

              pair xbounds=(-2,2);
              pair ybounds=(-2,2);
              pair zbounds=(-2,2);

              //xaxis3("",xbounds.x,xbounds.y,black,OutTicks(myxchoice),Arrow3(size=3mm));
              //yaxis3("",ybounds.x,ybounds.y,black,OutTicks(myychoice),Arrow3(size=3mm));
              //zaxis3("",zbounds.x,zbounds.y,black,OutTicks(myzchoice),Arrow3(size=3mm));

              //label("$x$",(xbounds.y+0.05*(xbounds.y-xbounds.x),0,0));
              //label("$y$",(0,ybounds.y+0.05*(ybounds.y-ybounds.x),0));
              //label("$z$",(0,0,zbounds.y+0.05*(zbounds.y-zbounds.x)));

              //plane is z=1-x+0.1y
              //Draw the surface
              //({cos(3*x)*cos(x)},{cos(3*x)*sin(x)},{(1-cos(3*x)*cos(x)+.1*cos(3*x)*sin(x))*y});
              triple f(pair t) {
                return (cos(3*t.x)*cos(t.x),cos(3*t.x)*sin(t.x),(1-cos(3*t.x)*cos(t.x)+.1*cos(3*t.x)*sin(t.x))*t.y);
              }
              surface s=surface(f,(0,0),(2*pi,1),32,32,Spline);
              pen p=apexmeshpen;
              draw(s,surfacepen,meshpen=p);

              //draw curve on xy plane //({cos(3*x)*cos(x)},{cos(3*x)*sin(x)},{0})
              triple g(real t) {return (cos(3*t)*cos(t),cos(3*t)*sin(t),0);}
              path3 mypath=graph(g,0,pi,operator ..);
              draw(mypath,bluepen+linewidth(2));


              //draw curves on surface
              triple g(real t) {return (cos(3*t)*cos(t),cos(3*t)*sin(t),1-(cos(3*t)*cos(t))+0.1*(cos(3*t)*sin(t)));}
              path3 mypath=graph(g,0,pi,operator ..);
              draw(mypath,bluepen+linewidth(2));


              //Shade the bottom
              import three;
              path3 p =  (0,0,0)..(.175,0.064,0)..(.264,.119,0)..(0.683,0.183,0)..(.916,0.121,0)..(1,0,0)..(.916,-0.121,0)..(0.683,-0.183,0)..(.264,-.119,0)..(.175,-0.086,0);
              draw(surface(p -- cycle), simplesurfacepen);

              path3 p = (0,0,0)..(-0.1429, 0.1196,0)..(-0.2351, 0.1691,0)..(-0.5000, 0.5000,0)..(-0.5628, 0.7328,0)..(-0.5000, 0.8660,0)..(-0.3532, 0.8538,0)..(-0.1830, 0.6830,0)..(-0.0289, 0.2881,0)..(-0.0130, 0.1946,0);
              draw(surface(p -- cycle), simplesurfacepen);

              path3 p = (0,0,0)..(-0.0321,-0.1836,0)..(-0.0289,-0.2881,0)..(-0.1830,-0.6830,0)..(-0.3532,-0.8538,0)..(-0.5000,-0.8660,0)..(-0.5628,-0.7328,0)..(-0.5000,-0.5000,0)..(-0.2351,-0.1691,0)..(-0.1620,-0.1086,0);
              draw(surface(p -- cycle), simplesurfacepen);

              //Shade the top
              path3 p = (0,0,1.0000)..(-0.1429,0.1196,1.1549)..(-0.2351,0.1691,1.2520)..(-0.5000,0.5000,1.5500)..(-0.5628,0.7328,1.6361)..(-0.5000,0.8660,1.5866)..(-0.3532,0.8538,1.4386)..(-0.1830 ,0.6830 ,1.2513)..(-0.0289,0.2881,1.0578)..(-0.0130,0.1946,1.0325);

              draw(surface(p -- cycle), simplesurfacepen);
              path3 p = (0 ,        0  ,  1.0000)..(-0.0321 ,  -0.1836 ,   1.0137)..(-0.0289,   -0.2881,    1.0001)..(-0.1830,   -0.6830,    1.1147)..(-0.3532  , -0.8538 ,   1.2678)..(-0.5000,   -0.8660 ,   1.4134)..(-0.5628 ,  -0.7328,    1.4895)..(-0.5000 ,  -0.5000 ,   1.4500)..(-0.2351 ,  -0.1691 ,   1.2181)..(-0.1620 ,  -0.1086,    1.1511);
              draw(surface(p -- cycle), simplesurfacepen);

              path3 p = (0 ,        0,    1.0000)..( 0.1750,    0.0640 ,   0.8314)..( 0.2640,    0.1190 ,   0.7479)..( 0.6830,    0.1830 ,   0.3353)..( 0.9160,    0.1210 ,   0.0961)..( 1.0000,         0 ,        0)..( 0.9160,   -0.1210 ,   0.0719)..( 0.6830,   -0.1830 ,   0.2987)..( 0.2640,   -0.1190 ,   0.7241)..( 0.1750,   -0.0860 ,   0.8164);
              draw(surface(p -- cycle), simplesurfacepen);
            </asymptote>
          </image>
        </figure>
      </statement>
      <solution>
        <p>
          We convert the equation of the plane to use cylindrical coordinates:
          <m>z= 1-r\cos(\theta)+0.1r\sin(\theta)</m>.
          Thus the region is space is bounded by <m>0 \leq z \leq 1-r\cos(\theta) + 0.1r\sin(\theta)</m>,
          <m>0 \leq r \leq \cos(3\theta)</m>,
          <m>0 \leq \theta \leq \pi</m> (recall that the rose curve
          <m>r=\cos(3\theta)</m> is traced out once on <m>[0,\pi]</m>.
        </p>

        <p>
          Since density is constant,
          we set <m>\delta = 1</m> and finding the mass is equivalent to finding the volume of the solid.
          We set up the triple integral to compute this but do not evaluate it;
          we leave it to the reader to confirm it evaluates to the same result found in <xref ref="ex_doublepol4">Example</xref>.
          <me>
            M = \iiint_D\delta \, dV = \int_0^{\pi}\int_0^{\cos(3\theta)}\int_0^{1-r\cos(\theta)+0.1r\sin(\theta)} r\,dz\,dr\,d\theta \approx 0.785
          </me>.
        </p>

        <p>
          From <xref ref="def_mass_3d">Definition</xref>
          we set up the triple integrals to compute the moments about the three coordinate planes.
          The computation of each is left to the reader (using technology is recommended):
          <md>
            <mrow>M_{yz} = \iiint_D x\,dV \amp = \int_0^{\pi}\int_0^{\cos(3\theta)}\int_0^{1-r\cos(\theta)+0.1r\sin(\theta)} (r\cos(\theta)) r\,dz\,dr\,d\theta</mrow>
            <mrow>\amp = -0.147</mrow>
          </md>.
          <md>
            <mrow>M_{xz} = \iiint_D y\,dV \amp = \int_0^{\pi}\int_0^{\cos(3\theta)}\int_0^{1-r\cos(\theta)+0.1r\sin(\theta)} (r\sin(\theta)) r\,dz\,dr\,d\theta</mrow>
            <mrow>\amp = 0.015.</mrow>
            <mrow>M_{xy} = \iiint_D z\,dV \amp = \int_0^{\pi}\int_0^{\cos(3\theta)}\int_0^{1-r\cos(\theta)+0.1r\sin(\theta)} (z) r\,dz\,dr\,d\theta</mrow>
            <mrow>\amp = 0.467</mrow>
          </md>.
        </p>

        <p>
          The center of mass, in rectangular coordinates,
          is located at <m>(-0.147,0.015,0.467)</m>,
          which lies outside the bounds of the solid.
        </p>
      </solution>
    </example>
  </subsection>

  <subsection>
    <title>Spherical Coordinates</title>
    <p>
          <idx><h>spherical coordinates</h></idx>
          <idx><h>coordinates</h><h>spherical</h></idx>
    </p>

    <p>
      In short, spherical coordinates can be thought of as a
      <q>double application</q>
      of the polar coordinate system.
      In spherical coordinates,
      a point <m>P</m> is identified with <m>(\rho,\theta,\varphi)</m>,
      where <m>\rho</m> is the distance from the origin to <m>P</m>,
      <m>\theta</m> is the same angle as would be used to describe <m>P</m> in the cylindrical coordinate system,
      and <m>\varphi</m> is the angle between the positive <m>z</m>-axis and the ray from the origin to <m>P</m>;
      see <xref ref="fig_sphericalintro">Figure</xref>.
      So that each point in space that does not lie on the <m>z</m>-axis is defined uniquely,
      we will restrict <m>\rho \geq 0</m>,
      <m>0 \leq \theta \leq 2\pi</m> and <m>0 \leq \varphi \leq \pi</m>.
    </p>
    <aside>
      <p>
        The symbol <m>\rho</m> is the Greek letter <q>rho.</q>
        Traditionally it is used in the spherical coordinate system,
        while <m>r</m> is used in the polar and cylindrical coordinate systems.
      </p>
    </aside>
    <figure xml:id="fig_sphericalintro">
      <caption>Illustrating the principles behind spherical coordinates</caption>
      <image xml:id="img_sphericalintro_3D" width="47%">
        <description></description>
        <asymptote>

          //import apexstyle;


          //ASY file for figsphericalintro.asy in Chapter 13


          size(282,282,IgnoreAspect);
          //currentprojection=perspective(7,2,1);
          currentprojection=orthographic(24,17,11.6);
          defaultrender.merge=true;

          // setup and draw the axes
          real[] myxchoice={};
          real[] myychoice={};
          real[] myzchoice={};
          defaultpen(0.5mm);

          pair xbounds=(-.1,1.1);
          pair ybounds=(-.1,1.1);
          pair zbounds=(-.1,1.1);

          xaxis3("",xbounds.x,xbounds.y,black,OutTicks(myxchoice),Arrow3(size=3mm));
          yaxis3("",ybounds.x,ybounds.y,black,OutTicks(myychoice),Arrow3(size=3mm));
          zaxis3("",zbounds.x,zbounds.y,black,OutTicks(myzchoice),Arrow3(size=3mm));

          label("$x$",(xbounds.y+0.05*(xbounds.y-xbounds.x),0,0));
          label("$y$",(0,ybounds.y+0.05*(ybounds.y-ybounds.x),0));
          label("$z$",(0,0,zbounds.y+0.05*(zbounds.y-zbounds.x)));

          draw((.5,sqrt(3)/2,1)--(.5,sqrt(3)/2,0)--(0,0,0)--cycle,dashed);

          draw(arc((0,0,0),(.5,0,0),(.25,sqrt(3)/4,0)),Arrow3(size=2mm));

          draw(arc((0,0,0),(0,0,0.5),(.5,sqrt(3)/2,1)*.5/1.414),Arrow3(size=2mm));

          guide3 myarc=arc((0,0,0),(0,0,0.5),(.5,sqrt(3)/2,1)*.5/1.414);

          label("$\varphi$",myarc,NE);


          dot((.5,sqrt(3)/2,1),dotblue);

          label("$\theta$",(.55*cos(pi/6),.55*sin(pi/6),.1));

          label("$(\rho,\theta,\varphi)$",(.5,sqrt(3)/2,1.1));

          //label("$z$",(.5,sqrt(3)/2+.1,.5));

          label("$\rho$",(.5,sqrt(3)/2,1)*.5+(0.05,0.05,-.05));

          //draw(s,emissive(gray+opacity(.3)),meshpen=invisible);


          //draw(s,simplesurfacepen,meshpen=apexmeshpen);
        </asymptote>
      </image>
    </figure>

    <figure xml:id="vid-multint-spherical-intro" component="video">
      <caption>Introducing spherical coordinates</caption>
      <video youtube="In5up-a1jMI"/>
    </figure>

    <p>
      The following Key Idea gives conversions to/from our three spatial coordinate systems.
    </p>

    <insight xml:id="idea_convert_coords">
      <title>Converting Between Rectangular, Cylindrical and Spherical Coordinates</title>
      <p>
        <term>Rectangular and Cylindrical</term>
        <md>
          <mrow>\amp r^2 = x^2+y^2, \amp \amp \tan(\theta) = y/x,\amp  z\amp=z</mrow>
          <mrow>\amp x=r\cos(\theta), \amp \amp y =r\sin(\theta),\amp  z\amp =z</mrow>
        </md>
      </p>

      <p>
        <term>Rectangular and Spherical</term>
        <md>
          <mrow>\amp \rho = \sqrt{x^2+y^2+z^2}, \amp \amp \tan(\theta) = y/x, \amp \amp \cos(\varphi) = z/\sqrt{x^2+y^2+z^2}</mrow>
          <mrow>\amp x=\rho\sin(\varphi)\cos(\theta),\amp \amp y=\rho\sin(\varphi)\sin(\theta),\amp \amp z=\rho\cos(\varphi)</mrow>
        </md>
      </p>

      <p>
        <term>Cylindrical and Spherical </term>
        <md>
          <mrow>\amp \rho =\sqrt{r^2+z^2},\amp \amp  \theta = \theta,\amp \amp \tan(\varphi) = r/z</mrow>
          <mrow>\amp r=\rho \sin(\varphi),\amp \amp  \theta = \theta,\amp \amp z=\rho\cos(\varphi)</mrow>
        </md>
      </p>
    </insight>

    <aside>
      <p>
        The role of <m>\theta</m> and <m>\varphi</m> in spherical coordinates differs between mathematicians and physicists.
        When reading about physics in spherical coordinates,
        be careful to note how that particular author uses these variables and recognize that these identities will may no longer be valid.
      </p>
    </aside>

    <example xml:id="ex_spherical4">
      <title>Converting between rectangular and spherical coordinates</title>
      <statement>
        <p>
          Convert the rectangular point
          <m>(2,-2,1)</m> to spherical coordinates,
          and convert the spherical point
          <m>(6,\pi/3,\pi/2)</m> to rectangular and cylindrical coordinates.
        </p>
      </statement>
      <solution>
        <p>
          This rectangular point is the same as used in <xref ref="ex_cylindrical4">Example</xref>.
          Using <xref ref="idea_convert_coords">Key Idea</xref>,
          we find <m>\rho = \sqrt{2^2+(-1)^2+1^2} = 3</m>.
          Using the same logic as in <xref ref="ex_cylindrical4">Example</xref>,
          we find <m>\theta = 7\pi/4</m>.
          Finally, <m>\cos(\varphi) = 1/3</m>,
          giving <m>\varphi = \cos^{-1}(1/3) \approx 1.23</m>,
          or about <m>70.53^\circ</m>.
          Thus the spherical coordinates are approximately <m>(3,7\pi/4,1.23)</m>.
        </p>

        <p>
          Converting the spherical point <m>(6,\pi/3,\pi/2)</m> to rectangular,
          we have <m>x = 6\sin(\pi/2)\cos(\pi/3) = 3</m>,
          <m>y = 6\sin(\pi/2)\sin(\pi/3) = 3\sqrt{3}</m> and <m>z = 6\cos(\pi/2) = 0</m>.
          Thus the rectangular coordinates are <m>(3,3\sqrt{3},0)</m>.
        </p>

        <p>
          To convert this spherical point to cylindrical,
          we have <m>r = 6\sin(\pi/2) = 6</m>,
          <m>\theta = \pi/3</m> and <m>z = 6\cos(\pi/2) =0</m>,
          giving the cylindrical point <m>(6,\pi/3,0)</m>.
        </p>
      </solution>
    </example>

    <example xml:id="ex_spherical1">
      <title>Canonical surfaces in spherical coordinates</title>
      <statement>
        <p>
          Describe the surfaces <m>\rho=1</m>,
          <m>\theta = \pi/3</m> and <m>\varphi = \pi/6</m>,
          given in spherical coordinates.
        </p>
      </statement>
      <solution>
        <p>
          The equation <m>\rho = 1</m> describes all points in space that are 1 unit away from the origin:
          this is the sphere of radius 1, centered at the origin.
        </p>

        <p>
          The equation <m>\theta = \pi/3</m> describes the same surface in spherical coordinates as it does in cylindrical coordinates:
          beginning with the line <m>\theta = \pi/3</m> in the <m>xy</m>-plane as given by polar coordinates,
          extend the line parallel to the <m>z</m>-axis, forming a plane.
        </p>

        <p>
          The equation <m>\varphi=\pi/6</m> describes all points <m>P</m> in space where the ray from the origin to <m>P</m> makes an angle of <m>\pi/6</m> with the positive <m>z</m>-axis.
          This describes a cone,
          with the positive <m>z</m>-axis its axis of symmetry, with point at the origin.
        </p>

        <figure xml:id="fig_spherical1">
          <caption>Graphing the canonical surfaces in spherical coordinates from <xref ref="ex_spherical1">Example</xref></caption>
          <image xml:id="img_spherical1_3D" width="47%">
            <description></description>
            <asymptote>

              //import apexstyle;


              //ASY file for figspherical1_3D.asy in Chapter 13


              size(282,282,IgnoreAspect);
              //currentprojection=perspective(7,2,1);
              currentprojection=orthographic(27,13,9);
              defaultrender.merge=true;

              // setup and draw the axes
              real[] myxchoice={1};
              real[] myychoice={1};
              real[] myzchoice={1};
              defaultpen(0.5mm);

              pair xbounds=(-2,2);
              pair ybounds=(-2,2);
              pair zbounds=(-1.5,2);

              xaxis3("",xbounds.x,xbounds.y,black,OutTicks(myxchoice),Arrow3(size=3mm));
              yaxis3("",ybounds.x,ybounds.y,black,OutTicks(myychoice),Arrow3(size=3mm));
              zaxis3("",zbounds.x,zbounds.y,black,OutTicks(myzchoice),Arrow3(size=3mm));

              label("$x$",(xbounds.y+0.05*(xbounds.y-xbounds.x),0,0));
              label("$y$",(0,ybounds.y+0.05*(ybounds.y-ybounds.x),0));
              label("$z$",(0,0,zbounds.y+0.05*(zbounds.y-zbounds.x)));


              //Draw the plane  z=7-2x-2y
              triple f(pair t) {
              	return (t.y*cos(t.x),t.y*sin(t.x),sqrt(3)*t.y);//
              }
              surface s=surface(f,(0,0),(2*pi,1.5/sqrt(3)),16,4,usplinetype=new splinetype[] {notaknot,notaknot,monotonic},vsplinetype=new splinetype[] {notaknot,notaknot,monotonic});
              pen p=bluemeshpen+.1mm;
              draw(s,simplesurfacepen,meshpen=p);

              //draw((-1.5,-1.5,2) -- (-1.5,1.5,2) -- (1.5,1.5,2) -- (1.5,-1.5,2) -- (-1.5,-1.5,2),apexmeshpen+.25mm);

              triple g(real t) {return (1.5/sqrt(3)*cos(t),1.5/sqrt(3)*sin(t),1.5);}
              path3 mypath=graph(g,0,2*pi,operator ..);
              draw(mypath,apexmeshpen);

              //Draw the plane  z=7-2x-2y
              triple f(pair t) {
              	return (t.x,t.x*sqrt(3),t.y);//
              }
              surface s=surface(f,(0,-1.25),(1.25,1.5),4,4,usplinetype=new splinetype[] {notaknot,notaknot,monotonic},vsplinetype=new splinetype[] {notaknot,notaknot,monotonic});
              pen q=redmeshpen2+.1mm;
              draw(s,simplesurfacepen2,meshpen=q);

              draw((0,0,-1.25) -- (1.25,1.25*sqrt(3),-1.25) -- (1.25,1.25*sqrt(3),1.5) -- (0,0,1.5) -- (0,0,-1.5),redcurvepen+.25mm);


              //Draw the plane  z=7-2x-2y
              triple f(pair t) {
              	return (sin(t.y)*cos(t.x),sin(t.y)*sin(t.x),cos(t.y));//
              }
              surface s=surface(f,(0,0),(2*pi,pi),16,16,usplinetype=new splinetype[] {notaknot,notaknot,monotonic},vsplinetype=new splinetype[] {notaknot,notaknot,monotonic});
              pen q=greenmeshpen+.1mm;
              draw(s,simplesurfacepen3,meshpen=q);

              //dot((.5,sqrt(3)*.5,2),rgb(.1,.1,.1));

              //draw((.5,sqrt(3)*.5,-.5)--(.5,sqrt(3)*.5,2.25));

              triple g(real t) {return (1/2*cos(t),1/2*sin(t),1/2*sqrt(3));}
              path3 mypath=graph(g,0,2*pi,operator ..);
              draw(mypath,blackmeshpen);

              //(1.5/sqrt(3)*cos(t),1.5/sqrt(3)*sin(t),1.5)
              draw((0,0,0) -- (1.5/sqrt(3)*cos(pi/3),1.5/sqrt(3)*sin(pi/3),1.5));

              triple g(real t) {return (sin(t)*cos(pi/3),sin(t)*sin(pi/3),cos(t));}
              path3 mypath=graph(g,0,pi,operator ..);
              draw(mypath,blackmeshpen);

              triple g(real t) {return (cos(t),sin(t),-.5);}
              path3 mypath=graph(g,0,2*pi,operator ..);
              //draw(mypath,greencurvepen+.25mm);

              triple g(real t) {return (t,sqrt(3)*t,2);}
              path3 mypath=graph(g,-.866,.866,operator ..);
              //draw(mypath,blackmeshpen);

              //draw(s,emissive(gray+opacity(.3)),meshpen=invisible);


              //draw(s,simplesurfacepen,meshpen=apexmeshpen);



              label("$\varphi=\frac{\pi}{6}$",(1.5/sqrt(3)*cos(2pi/3),1.5/sqrt(3)*sin(2pi/3),1.5),E);
              label("$\rho=1$",(1.1*cos(pi/200),1.1*sin(pi/200),-.9));
              label("$\theta=\frac{\pi}{3}$",(1.25,1.25*sqrt(3),1));

              //draw((0,1,0)--(0,3,0)--(3,1,0)--cycle,curvepen);
            </asymptote>
          </image>
        </figure>

        <p>
          All three surfaces are graphed in <xref ref="fig_spherical1">Figure</xref>.
          Note how their intersection uniquely defines the point <m>P=(1,\pi/3,\pi/6)</m>.
        </p>
      </solution>
    </example>

    <p>
      Spherical coordinates are useful when describing certain domains in space,
      allowing us to evaluate triple integrals over these domains more easily than if we used rectangular coordinates or cylindrical coordinates.
      The crux of setting up a triple integral in spherical coordinates is appropriately describing the
      <q>small amount of volume,</q>
      <m>dV</m>, used in the integral.
    </p>

    <p>
      Considering <xref ref="fig_sphericalwedge">Figure</xref>,
      we can make a small <q>spherical wedge</q> by varying <m>\rho</m>,
      <m>\theta</m> and <m>\varphi</m> each a small amount, <m>\Delta\rho</m>,
      <m>\Delta\theta</m> and <m>\Delta\varphi</m>, respectively.
      This wedge is approximately a rectangular solid when the change in each coordinate is small,
      giving a volume of about
      <me>
        \Delta V \approx \Delta\rho\ \times\ \rho\Delta\varphi\ \times\ \rho\sin(\varphi)\Delta\theta
      </me>.
    </p>

    <figure xml:id="fig_sphericalwedge">
      <caption>Approximating the volume of a standard region in space using spherical coordinates</caption>
      <image xml:id="img_sphericalwedge_3D" width="47%">
        <description></description>
        <asymptote>

          //import apexstyle;


          //ASY file for figspherical1_3D.asy in Chapter 13


          size(282,282,IgnoreAspect);
          //currentprojection=perspective(7,2,1);
          currentprojection=orthographic(14.4,2.6,10);
          defaultrender.merge=true;

          // setup and draw the axes
          real[] myxchoice={};
          real[] myychoice={};
          real[] myzchoice={};
          defaultpen(0.5mm);

          pair xbounds=(-.1,.6);
          pair ybounds=(-.1,.6);
          pair zbounds=(-.1,1);

          xaxis3("",xbounds.x,xbounds.y,black,OutTicks(myxchoice),Arrow3(size=3mm));
          yaxis3("",ybounds.x,ybounds.y,black,OutTicks(myychoice),Arrow3(size=3mm));
          zaxis3("",zbounds.x,zbounds.y,black,OutTicks(myzchoice),Arrow3(size=3mm));

          label("$x$",(xbounds.y+0.05*(xbounds.y-xbounds.x),0,0));
          label("$y$",(0,ybounds.y+0.05*(ybounds.y-ybounds.x),0));
          label("$z$",(0,0,zbounds.y+0.05*(zbounds.y-zbounds.x)));


          real t1=pi/3-.2;
          real t2=pi/3+.2;
          real p1=pi/6-.2;
          real p2=pi/6+.2;
          real r1=.75;
          real r2=.9;



          //Draw the plane  z=7-2x-2y
          triple f(pair t) {
          	return (r1*cos(t.x)*sin(t.y),r1*sin(t.x)*sin(t.y),r1*cos(t.y));//
          }
          surface s=surface(f,(t1,p1),(t2,p2),4,4,usplinetype=new splinetype[] {notaknot,notaknot,monotonic},vsplinetype=new splinetype[] {notaknot,notaknot,monotonic});
          pen p=apexmeshpen+.1mm;
          draw(s,simplesurfacepen,meshpen=p);


          triple f(pair t) {
          	return (r2*cos(t.x)*sin(t.y),r2*sin(t.x)*sin(t.y),r2*cos(t.y));//
          }
          surface s=surface(f,(t1,p1),(t2,p2),4,4,usplinetype=new splinetype[] {notaknot,notaknot,monotonic},vsplinetype=new splinetype[] {notaknot,notaknot,monotonic});
          draw(s,simplesurfacepen,meshpen=p);


          triple f(pair t) {
          	return (t.y*cos(t.x)*sin(p1),t.y*sin(t.x)*sin(p1),t.y*cos(p1));//
          }
          surface s=surface(f,(t1,r1),(t2,r2),4,4,usplinetype=new splinetype[] {notaknot,notaknot,monotonic},vsplinetype=new splinetype[] {notaknot,notaknot,monotonic});
          draw(s,simplesurfacepen,meshpen=p);


          triple f(pair t) {
          	return (t.y*cos(t.x)*sin(p2),t.y*sin(t.x)*sin(p2),t.y*cos(p2));//
          }
          surface s=surface(f,(t1,r1),(t2,r2),4,4,usplinetype=new splinetype[] {notaknot,notaknot,monotonic},vsplinetype=new splinetype[] {notaknot,notaknot,monotonic});
          draw(s,simplesurfacepen,meshpen=p);


          triple f(pair t) {
          	return (t.y*cos(t1)*sin(t.x),t.y*sin(t1)*sin(t.x),t.y*cos(t.x));//
          }
          surface s=surface(f,(p1,r1),(p2,r2),4,4,usplinetype=new splinetype[] {notaknot,notaknot,monotonic},vsplinetype=new splinetype[] {notaknot,notaknot,monotonic});
          draw(s,simplesurfacepen,meshpen=p);


          triple f(pair t) {
          	return (t.y*cos(t2)*sin(t.x),t.y*sin(t2)*sin(t.x),t.y*cos(t.x));//
          }
          surface s=surface(f,(p1,r1),(p2,r2),4,4,usplinetype=new splinetype[] {notaknot,notaknot,monotonic},vsplinetype=new splinetype[] {notaknot,notaknot,monotonic});
          draw(s,simplesurfacepen,meshpen=p);


          //
          // lines for phi
          //
          draw((r1*cos(t1)*sin(p1),r1*sin(t1)*sin(p1),r1*cos(p1)) -- (0,0,0) -- (r1*cos(t1)*sin(p2),r1*sin(t1)*sin(p2),r1*cos(p2)),black+.25mm+dashed);

          draw(arc((0,0,0),(r1*cos(t1)*sin(p1)/2.5,r1*sin(t1)*sin(p1)/2.5,r1*cos(p1)/2.5),(r1*cos(t1)*sin(p2)/2.5,r1*sin(t1)*sin(p2)/2.5,r1*cos(p2)/2.5)),black+.25mm,Arrow3(size=1.5mm));

          label("$\Delta\varphi$",.95*(r1*cos(t1)*sin((p1+p2)/2)/2,r1*sin(t1)*sin((p1+p2)/2)/2,r1*cos((p1+p2)/2)/2));



          //
          //  lines for theta
          //

          draw((0,0,0) -- (r1*cos(t1)*sin(p2),r1*sin(t1)*sin(p2),0) -- (r1*cos(t1)*sin(p2),r1*sin(t1)*sin(p2),r1*cos(p2)),black+.25mm+dashed);

          draw((0,0,0) -- (r1*cos(t2)*sin(p2),r1*sin(t2)*sin(p2),0) -- (r1*cos(t2)*sin(p2),r1*sin(t2)*sin(p2),r1*cos(p2)),black+.25mm+dashed);

          draw(arc((0,0,0),.5*(r1*cos(t1)*sin(p2),r1*sin(t1)*sin(p2),0),.5*(r1*cos(t2)*sin(p2),r1*sin(t2)*sin(p2),0)),black+.25mm,Arrow3(size=1.5mm));

          label("$\Delta\theta$",1.2*.5*(r1*cos((t1+t2)/2)*sin(p2),r1*sin((t1+t2)/2)*sin(p2),0));

          //
          // lines for rho
          //

          draw(arc((0,0,0),(r1*cos(t1)*sin(0),r1*sin(t1)*sin(0),r1*cos(0)),(r1*cos(t1)*sin(p1),r1*sin(t1)*sin(p1),r1*cos(p1))),black+.25mm+dashed);

          draw(arc((0,0,0),(r2*cos(t1)*sin(0),r2*sin(t1)*sin(0),r2*cos(0)),(r2*cos(t1)*sin(p1),r2*sin(t1)*sin(p1),r2*cos(p1))),black+.25mm+dashed);


          label("$\Delta\rho$",((r1+r2)/2*cos(t1)*sin(.65*(p1)),(r1+r2)/2*sin(t1)*sin(.65*(p1)),(r1+r2)/2*cos(.65*(p1))));

          real poff = -0.05;

          draw((r1*cos(t1)*sin(p1+poff),r1*sin(t1)*sin(p1+poff),r1*cos(p1+poff)) -- (r2*cos(t1)*sin(p1+poff),r2*sin(t1)*sin(p1+poff),r2*cos(p1+poff)),black+.25mm,Arrows3(size=1.5mm));

          label("$\rho$",(0,-.04,.5*r1));

          draw((0,-.02,.01) -- (0,-.02,.99*r1),black+.25mm,Arrows3(size=1.5mm));


          //
          //  lines for theta length
          //

          draw((r1*cos(t1)*sin(p2),r1*sin(t1)*sin(p2),r1*cos(p2)-.05) -- (r1*cos(t2)*sin(p2),r1*sin(t2)*sin(p2),r1*cos(p2)-.05),black+.25mm,Arrows3(size=1.5mm));

          label("$\rho\sin(\varphi)\Delta\theta$",1.5*((r1*cos(t1)*sin(p2),r1*sin(t1)*sin(p2),r1*cos(p2)-.05) + (r1*cos(t2)*sin(p2),r1*sin(t2)*sin(p2),r1*cos(p2)-.05)+(0,0,-.05))/2+(0,0,-.25),S);

          draw(1.5*((r1*cos(t1)*sin(p2),r1*sin(t1)*sin(p2),r1*cos(p2)-.05) + (r1*cos(t2)*sin(p2),r1*sin(t2)*sin(p2),r1*cos(p2)-.05)+(0,0,-.05))/2 + (0,0,-.25) -- 1.05((r1*cos(t1)*sin(p2),r1*sin(t1)*sin(p2),r1*cos(p2)-.05) + (r1*cos(t2)*sin(p2),r1*sin(t2)*sin(p2),r1*cos(p2)-.05))/2+(0,0,-.01),black+.25mm+dashed,Arrow3(size=1.5mm));

          //
          // lines for phi length
          //

          label("$\rho\Delta\varphi$",.85*(r1*cos(t1)*sin((p1+p2)/2),r1*sin(t1)*sin((p1+p2)/2),r1*cos((p1+p2)/2)));

          draw(arc((0,0,0),.95*(r1*cos(t1)*sin(p1),r1*sin(t1)*sin(p1),r1*cos(p1)),.95*(r1*cos(t1)*sin(p2),r1*sin(t1)*sin(p2),r1*cos(p2))),black+.25mm,Arrows3(size=1.5mm));
        </asymptote>
      </image>
    </figure>

    <p>
      Given a region <m>D</m> in space,
      we can approximate the volume of <m>D</m> with many such wedges.
      As the size of each of <m>\Delta\rho</m>,
      <m>\Delta\theta</m> and <m>\Delta\varphi</m> goes to zero,
      the number of wedges increases to infinity and the volume of <m>D</m> is more accurately approximated, giving
      <me>
        dV = d\rho\ \times\ \rho\, d\varphi\ \times\ \rho\sin(\varphi)d\theta = \rho^2\sin(\varphi)\, d\rho\, d\theta\, d\varphi
      </me>.
    </p>

    <p>
      Again, this development of <m>dV</m> should sound reasonable,
      and the following theorem states it is the appropriate manner by which triple integrals are to be evaluated in spherical coordinates.
    </p>
    <aside>
      <p>
        It is generally most intuitive to evaluate the triple integral in <xref ref="thm_triple_int_spherical">Theorem</xref>
        by integrating with respect to <m>\rho</m> first;
        it often does not matter whether we next integrate with respect to <m>\theta</m> or <m>\varphi</m>.
        Different texts present different standard orders,
        some preferring <m>d\varphi\, d\theta</m> instead of <m>d\theta\, d\varphi</m>.
        As the bounds for these variables are usually constants in practice,
        it generally is a matter of preference.
      </p>
    </aside>

    <theorem xml:id="thm_triple_int_spherical">
      <title>Triple Integration in Spherical Coordinates</title>
      <statement>
        <p>
          Let <m>w=h(\rho,\theta,\varphi)</m> be a continuous function on a closed,
          bounded region <m>D</m> in space,
          bounded in spherical coordinates by <m>\alpha_1 \leq \varphi \leq \alpha_2</m>,
          <m>\beta_1 \leq \theta \leq \beta_2</m> and <m>f_1(\theta,\varphi) \leq \rho \leq f_2(\theta,\varphi)</m>.
          Then <idx><h>integration</h><h>with spherical coordinates</h></idx>
          <me>
            \iiint_D h(\rho,\theta,\varphi)\, dV = \int_{\alpha_1}^{\alpha_2}\int_{\beta_1}^{\beta_2}\int_{f_1(\theta,\varphi)}^{f_2(\theta,\varphi)} h(\rho,\theta,\varphi) \rho^2\sin(\varphi)\, d\rho\, d\theta\, d\varphi
          </me>.
        </p>
      </statement>
    </theorem>

    <example xml:id="ex_spherical2">
      <title>Establishing the volume of a sphere</title>
      <statement>
        <p>
          Let <m>D</m> be the region in space bounded by the sphere,
          centered at the origin, of radius <m>r</m>.
          Use a triple integral in spherical coordinates to find the volume <m>V</m> of <m>D</m>.
        </p>
      </statement>
      <solution>
        <p>
          The sphere of radius <m>r</m>,
          centered at the origin, has equation <m>\rho = r</m>.
          To obtain the full sphere,
          the bounds on <m>\theta</m> and <m>\varphi</m> are
          <m>0\leq \theta \leq 2\pi</m> and <m>0 \leq \varphi \leq \pi</m>.
          This leads us to:
          <md>
            <mrow>V \amp = \iiint_D\, dV</mrow>
            <mrow>\amp = \int_0^{\pi}\int_0^{2\pi}\int_0^r\big(\rho^2\sin(\varphi)\big)\, d\rho\, d\theta\, d\varphi</mrow>
            <mrow>\amp = \int_0^\pi\int_0^{2\pi}\left(\frac13\rho^3\sin(\varphi)\Big|_0^r\right)\, d\theta\, d\varphi</mrow>
            <mrow>\amp = \int_0^\pi\int_0^{2\pi} \left(\frac13r^3\sin(\varphi)\right)\, d\theta\, d\varphi</mrow>
            <mrow>\amp = \int_0^\pi \left(\frac{2\pi}3r^3\sin(\varphi)\right)\, d\varphi</mrow>
            <mrow>\amp = \left.\left(-\frac{2\pi}3r^3\cos(\varphi)\right)\right|_0^{\pi}</mrow>
            <mrow>\amp = \frac{4\pi}3r^3</mrow>
          </md>,
          the familiar formula for the volume of a sphere.
          Note how the integration steps were easy,
          not using square roots nor integration steps such as Substitution.
        </p>
      </solution>
    </example>

    <figure xml:id="vid-multint-spherical-example1" component="video">
      <caption>Setting up an integral in spherical coorindates</caption>
      <video youtube="wqjjslo0auI"/>
    </figure>

    <example xml:id="ex_spherical3">
      <title>Finding the center of mass using spherical coordinates</title>
      <statement>
        <p>
          Find the center of mass of the solid with constant density enclosed above by <m>\rho=4</m> and below by <m>\varphi = \pi/6</m>,
          as illustrated in <xref ref="fig_spherical3">Figure</xref>.
        </p>
        <figure xml:id="fig_spherical3">
          <caption>Graphing the solid, and its center of mass, from <xref ref="ex_spherical3">Example</xref></caption>
          <image xml:id="img_spherical3_3D" width="47%">
            <description></description>
            <asymptote>

              //import apexstyle;


              //ASY file for figspherical1_3D.asy in Chapter 13


              size(282,282,IgnoreAspect);
              //currentprojection=perspective(7,2,1);
              currentprojection=orthographic(12,13,3);
              defaultrender.merge=true;

              // setup and draw the axes
              real[] myxchoice={2};
              real[] myychoice={2};
              real[] myzchoice={4};
              defaultpen(0.5mm);

              pair xbounds=(-2.5,2.5);
              pair ybounds=(-2.5,2.5);
              pair zbounds=(-.1,5);

              xaxis3("",xbounds.x,xbounds.y,black,OutTicks(myxchoice),Arrow3(size=3mm));
              yaxis3("",ybounds.x,ybounds.y,black,OutTicks(myychoice),Arrow3(size=3mm));
              zaxis3("",zbounds.x,zbounds.y,black,OutTicks(myzchoice),Arrow3(size=3mm));

              label("$x$",(xbounds.y+0.05*(xbounds.y-xbounds.x),0,0));
              label("$y$",(0,ybounds.y+0.05*(ybounds.y-ybounds.x),0));
              label("$z$",(0,0,zbounds.y+0.05*(zbounds.y-zbounds.x)));


              //Draw the plane  z=7-2x-2y
              triple f(pair t) {
              	return (t.y*cos(t.x)*sin(pi/6),t.y*sin(t.x)*sin(pi/6),t.y*cos(pi/6));//
              }
              surface s=surface(f,(0,0),(2*pi,4),16,4,usplinetype=new splinetype[] {notaknot,notaknot,monotonic},vsplinetype=new splinetype[] {notaknot,notaknot,monotonic});
              pen p=apexmeshpen+.1mm;
              draw(s,simplesurfacepen,meshpen=p);

              //Draw the plane  z=7-2x-2y
              triple f(pair t) {
              	return (4*cos(t.x)*sin(t.y),4*sin(t.x)*sin(t.y),4*cos(t.y));//
              }
              surface s=surface(f,(0,0),(2*pi,pi/6),16,4,usplinetype=new splinetype[] {notaknot,notaknot,monotonic},vsplinetype=new splinetype[] {notaknot,notaknot,monotonic});
              draw(s,simplesurfacepen,meshpen=p);


              dot((0,0,2.799),blackmeshpen+1.2mm);


              //draw((-1.5,-1.5,2) -- (-1.5,1.5,2) -- (1.5,1.5,2) -- (1.5,-1.5,2) -- (-1.5,-1.5,2),apexmeshpen+.25mm);

              triple g(real t) {return (1.5/sqrt(3)*cos(t),1.5/sqrt(3)*sin(t),1.5);}
              path3 mypath=graph(g,0,2*pi,operator ..);
              //draw(mypath,apexmeshpen);

              //Draw the plane  z=7-2x-2y
              triple f(pair t) {
              	return (t.x,t.x*sqrt(3),t.y);//
              }
              surface s=surface(f,(-1.25,-1.5),(1.25,1.5),8,8,usplinetype=new splinetype[] {notaknot,notaknot,monotonic},vsplinetype=new splinetype[] {notaknot,notaknot,monotonic});
              pen q=redmeshpen;
              //draw(s,simplesurfacepen2,meshpen=q);

              //draw((-1.25,-1.25*sqrt(3),-1.5) -- (1.25,1.25*sqrt(3),-1.5) -- (1.25,1.25*sqrt(3),1.5) -- (-1.25,-1.25*sqrt(3),1.5) -- (-1.25,-1.25*sqrt(3),-1.5),redcurvepen+.25mm);


              //Draw the plane  z=7-2x-2y
              triple f(pair t) {
              	return (sin(t.y)*cos(t.x),sin(t.y)*sin(t.x),cos(t.y));//
              }
              surface s=surface(f,(0,0),(2*pi,pi),16,16,usplinetype=new splinetype[] {notaknot,notaknot,monotonic},vsplinetype=new splinetype[] {notaknot,notaknot,monotonic});
              pen q=greencurvepen;
              //draw(s,simplesurfacepen3,meshpen=q);

              //dot((.5,sqrt(3)*.5,2),rgb(.1,.1,.1));

              //draw((.5,sqrt(3)*.5,-.5)--(.5,sqrt(3)*.5,2.25));

              triple g(real t) {return (1/2*cos(t),1/2*sin(t),1/2*sqrt(3));}
              path3 mypath=graph(g,0,2*pi,operator ..);
              //draw(mypath,blackmeshpen);

              //(1.5/sqrt(3)*cos(t),1.5/sqrt(3)*sin(t),1.5)
              //draw((1.5/sqrt(3)*cos(4*pi/3),1.5/sqrt(3)*sin(4*pi/3),1.5) -- (0,0,0) -- (1.5/sqrt(3)*cos(pi/3),1.5/sqrt(3)*sin(pi/3),1.5));

              triple g(real t) {return (sin(t)*cos(pi/3),sin(t)*sin(pi/3),cos(t));}
              path3 mypath=graph(g,0,2*pi,operator ..);
              //draw(mypath,blackmeshpen);
            </asymptote>
          </image>
        </figure>
      </statement>
      <solution>
        <p>
          We will set up the four triple integrals needed to find the center of mass (<ie/>, to compute <m>M</m>,
          <m>M_{yz}</m>,
          <m>M_{xz}</m> and <m>M_{xy}</m>) and leave it to the reader to evaluate each integral.
          Because of symmetry,
          we expect the <m>x</m>- and <m>y</m>- coordinates of the center of mass to be 0.
        </p>

        <p>
          While the surfaces describing the solid are given in the statement of the problem,
          to describe the full solid <m>D</m>,
          we use the following bounds:
          <m>0 \leq \rho \leq 4</m>,
          <m>0 \leq \theta \leq 2\pi</m> and <m>0 \leq \varphi \leq \pi/6</m>.
          Since density <m>\delta</m> is constant,
          we assume <m>\delta =1</m>.
        </p>

        <p>
          The mass of the solid:
          <md>
            <mrow>M \amp = \iiint_D\, dm = \iiint_D\, dV</mrow>
            <mrow>\amp = \int_0^{\pi/6}\int_0^{2\pi}\int_0^4\big(\rho^2\sin(\varphi)\big)\, d\rho\, d\theta\, d\varphi</mrow>
            <mrow>\amp = \frac{64}3\big(2-\sqrt{3}\big)\pi \approx 17.958</mrow>
          </md>.
        </p>

        <p>
          To compute <m>M_{yz}</m>, the integrand is <m>x</m>;
          using <xref ref="idea_convert_coords">Key Idea</xref>,
          we have <m>x = \rho\sin(\varphi)\cos(\theta)</m>.
          This gives:
          <md>
            <mrow>M_{yz} \amp = \iiint_D x\, dm</mrow>
            <mrow>\amp = \int_0^{\pi/6}\int_0^{2\pi}\int_0^4 \big((\rho\sin(\varphi)\cos(\theta))\rho^2\sin(\varphi)\big) \, d\rho\, d\theta\, d\varphi</mrow>
            <mrow>\amp = \int_0^{\pi/6}\int_0^{2\pi}\int_0^4 \big(\rho^3\sin^2(\varphi)\cos(\theta)\big) \, d\rho\, d\theta\, d\varphi</mrow>
            <mrow>\amp =0</mrow>
          </md>,
          which we expected as we expect <m>\overline{x} = 0</m>.
        </p>

        <p>
          To compute <m>M_{xz}</m>, the integrand is <m>y</m>;
          using <xref ref="idea_convert_coords">Key Idea</xref>,
          we have <m>y = \rho\sin(\varphi)\sin(\theta)</m>.
          This gives:
          <md>
            <mrow>M_{xz} \amp = \iiint_D y\, dm</mrow>
            <mrow>\amp = \int_0^{\pi/6}\int_0^{2\pi}\int_0^4 \big((\rho\sin(\varphi)\sin(\theta))\rho^2\sin(\varphi)\big) \, d\rho\, d\theta\, d\varphi</mrow>
            <mrow>\amp = \int_0^{\pi/6}\int_0^{2\pi}\int_0^4 \big(\rho^3\sin^2(\varphi)\sin(\theta)\big) \, d\rho\, d\theta\, d\varphi</mrow>
            <mrow>\amp =0</mrow>
          </md>,
          which we also expected as we expect <m>\overline{y} = 0</m>.
        </p>

        <p>
          To compute <m>M_{xy}</m>, the integrand is <m>z</m>;
          using <xref ref="idea_convert_coords">Key Idea</xref>,
          we have <m>z = \rho\cos(\varphi)</m>.
          This gives:
          <md>
            <mrow>M_{xy} \amp = \iiint_D z\, dm</mrow>
            <mrow>\amp = \int_0^{\pi/6}\int_0^{2\pi}\int_0^4 \big((\rho\cos(\varphi))\rho^2\sin(\varphi)\big) \, d\rho\, d\theta\, d\varphi</mrow>
            <mrow>\amp = \int_0^{\pi/6}\int_0^{2\pi}\int_0^4 \big(\rho^3\cos(\varphi)\sin(\varphi)\big) \, d\rho\, d\theta\, d\varphi</mrow>
            <mrow>\amp =16\pi \approx 50.266</mrow>
          </md>.
        </p>

        <p>
          Thus the center of mass is <m>(0,0,M_{xy}/M) \approx (0,0,2.799)</m>,
          as indicated in <xref ref="fig_spherical3">Figure</xref>.
        </p>
      </solution>
    </example>

    <figure xml:id="vid-multint-spherical-examples" component="video">
      <caption>Two more spherical coordinate examples</caption>
      <video youtube="jwzvDiiM94o EKxY_5PlgTU"/>
    </figure>

    <p>
      This section has provided a brief introduction into two new coordinate systems useful for identifying points in space.
      Each can be used to define a variety of surfaces in space beyond the canonical surfaces graphed as each system was introduced.
    </p>

    <p>
      However, the usefulness of these coordinate systems does not lie in the variety of surfaces that they can describe nor the regions in space these surfaces may enclose.
      Rather, cylindrical coordinates are mostly used to describe cylinders and spherical coordinates are mostly used to describe spheres.
      These shapes are of special interest in the sciences, especially in physics,
      and computations on/inside these shapes is difficult using rectangular coordinates.
      For instance, in the study of electricity and magnetism,
      one often studies the effects of an electrical current passing through a wire;
      that wire is essentially a cylinder,
      described well by cylindrical coordinates.
    </p>

    <p>
      This chapter investigated the natural follow-on to partial derivatives:
      iterated integration.
      We learned how to use the bounds of a double integral to describe a region in the plane using both rectangular and polar coordinates,
      then later expanded to use the bounds of a triple integral to describe a region in space.
      We used double integrals to find volumes under surfaces,
      surface area,
      and the center of mass of lamina;
      we used triple integrals as an alternate method of finding volumes of space regions and also to find the center of mass of a region in space.
    </p>

    <p>
      Integration does not stop here.
      We could continue to iterate our integrals,
      next investigating <q>quadruple integrals</q>
      whose bounds describe a region in 4-dimensional space
      (which are very hard to visualize).
      We can also look back to <q>regular</q>
      integration where we found the area under a curve in the plane.
      A natural analogue to this is finding the
      <q>area under a curve,</q>
      where the curve is in space, not in a plane.
      These are just two of many avenues to explore under the heading of <q>integration.</q>
    </p>
  </subsection>

  <xi:include href="exer_sec_cylindrical_spherical.ptx" />
</section>
